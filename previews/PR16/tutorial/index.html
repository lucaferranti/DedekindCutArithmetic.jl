<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · DedekindCutArithmetic.jl</title><meta name="title" content="Tutorial · DedekindCutArithmetic.jl"/><meta property="og:title" content="Tutorial · DedekindCutArithmetic.jl"/><meta property="twitter:title" content="Tutorial · DedekindCutArithmetic.jl"/><meta name="description" content="Documentation for DedekindCutArithmetic.jl."/><meta property="og:description" content="Documentation for DedekindCutArithmetic.jl."/><meta property="twitter:description" content="Documentation for DedekindCutArithmetic.jl."/><meta property="og:url" content="https://lucaferranti.github.io/DedekindCutArithmetic.jl/tutorial/"/><meta property="twitter:url" content="https://lucaferranti.github.io/DedekindCutArithmetic.jl/tutorial/"/><link rel="canonical" href="https://lucaferranti.github.io/DedekindCutArithmetic.jl/tutorial/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="DedekindCutArithmetic.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DedekindCutArithmetic.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Motivation:-What-is-exact-real-arithmetic?"><span>Motivation: What is exact real arithmetic?</span></a></li><li><a class="tocitem" href="#Dyadic-numbers"><span>Dyadic numbers</span></a></li><li><a class="tocitem" href="#Dyadic-interval"><span>Dyadic interval</span></a></li><li><a class="tocitem" href="#Defining-cuts"><span>Defining cuts</span></a></li><li><a class="tocitem" href="#Cuts-with-quantifiers"><span>Cuts with quantifiers</span></a></li><li><a class="tocitem" href="#Working-with-float-literals"><span>Working with float literals</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../90-contributing/">Contributor&#39;s guide</a></li><li><a class="tocitem" href="../91-developer/">Developer documentation</a></li></ul></li><li><a class="tocitem" href="../changelog/">Release notes</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lucaferranti/DedekindCutArithmetic.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lucaferranti/DedekindCutArithmetic.jl/blob/main/docs/src/tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-Tutorial"><a class="docs-heading-anchor" href="#Basic-Tutorial">Basic Tutorial</a><a id="Basic-Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Tutorial" title="Permalink"></a></h1><p>This tutorial will guide you through the basic functionalities of <code>DedekindCutArithmetic.jl</code>. These examples assume you have loaded the library with</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using DedekindCutArithmetic</code></pre><h2 id="Motivation:-What-is-exact-real-arithmetic?"><a class="docs-heading-anchor" href="#Motivation:-What-is-exact-real-arithmetic?">Motivation: What is exact real arithmetic?</a><a id="Motivation:-What-is-exact-real-arithmetic?-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation:-What-is-exact-real-arithmetic?" title="Permalink"></a></h2><p>Whenever doing computations, we need to face the problem of rounding errors. Standard techniques to cope with it are</p><ul><li><em>floating point arithmetic</em>: use 64 bits or 32 bits to approximate real numbers. This is what happens by default when you type <code>0.1</code> in the julia REPL. It is the fastest of the options, but also loses accuracy the fastest.</li><li><em>arbitrary precision floating point arithmetic</em>: Set an arbitrary (within machine memory limits) precision <em>a priori</em> and do all computations using that precision. In Julia, this is achieved using <code>BigFloat</code>, which uses the C library MPFR under the hood. By default, it uses 256 bits of precision. This allows more accurate computations, but rounding error will still accumulate and for big enough inputs or long enough computations a significant loss of accuracy may still occur.</li><li><em>interval arithmetic</em>: Use intervals instead of numbers and perform all operations so that the resulting interval contains the true result. This will give a rigorous bound of the error. However, for several factors (directed rounding, dependency problem, wrapping effect) the width of the interval may grow too big and give an uninformative result.</li></ul><p>An alternative approach is <em>exact real arithmetic</em>, which sets a target precision and outputs the final result with that precision. The main difference from e.g. MPFR, is that here the precision is dynamic and is increased during computation. Everything has a tradeoff of course, and exact real arithmetic can be slower than MPFR or interval arithmetic, especially for long complex computations.</p><p>The following snippets gives a motivation example for exact real arithmetic. Obviously, <span>$(1 + a) - a$</span> should alwyas be <span>$1$</span>. However, we get a complete wrong answer both with 64 and 256 bits of precision. With interval arithmetic, we get an interval containing the correct answer, but too wide to be informative. With exact real arithmetic we get a sharp bound on the correct value.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_float = sqrt(2.0^520/3)</code><code class="nohighlight hljs ansi" style="display:block;">1.0696415022590987e78</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; res_float = (1 + a_float) - a_float</code><code class="nohighlight hljs ansi" style="display:block;">0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_mpfr = sqrt(big(2)^520/3)</code><code class="nohighlight hljs ansi" style="display:block;">1.069641502259098779385487024465316103175578685752867676917409781944216470474592e+78</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; res_mpfr = (1 + a_mpfr) - a_mpfr</code><code class="nohighlight hljs ansi" style="display:block;">0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using IntervalArithmetic</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_interval = sqrt(interval(big(2)^520//3))</code><code class="nohighlight hljs ansi" style="display:block;">[1.06964e+78, 1.06965e+78]₂₅₆_com</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; res_interval = (interval(1) + a_interval) - a_interval</code><code class="nohighlight hljs ansi" style="display:block;">[-32.0, 48.0]₂₅₆_com</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_era = sqrt(RationalCauchyCut(big(2)^520//3))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching low(::RationalCauchyCut)
The function `low` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  low(<span class="sgr91">::DyadicInterval</span>)
<span class="sgr90">   @</span> <span class="sgr35">DedekindCutArithmetic</span> <span class="sgr90">~/work/DedekindCutArithmetic.jl/DedekindCutArithmetic.jl/src/<span class="sgr4">interval.jl:32</span></span>
  low(<span class="sgr91">::DyadicReal</span>)
<span class="sgr90">   @</span> <span class="sgr35">DedekindCutArithmetic</span> <span class="sgr90">~/work/DedekindCutArithmetic.jl/DedekindCutArithmetic.jl/src/<span class="sgr4">dyadic.jl:90</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; res_era = (1 + a_era) - a_era</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `a_era` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code></pre><p>There are different approaches to exact real arithmetic. This library builds on the theoretical framework based on Dedekind cuts and Abstract stone duality, proposed in [<a href="../references/#bauer2008efficient">1</a>, <a href="../references/#bauer2009dedekind">2</a>] and first implemented in [<a href="../references/#marshall">3</a>]. Next, the basic functionalities of this library are presented.</p><h2 id="Dyadic-numbers"><a class="docs-heading-anchor" href="#Dyadic-numbers">Dyadic numbers</a><a id="Dyadic-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Dyadic-numbers" title="Permalink"></a></h2><p>The fundamental building block of our arithmetic is <em>dyadic numbers</em>, that is, a number in the form <span>$\frac{m}{e^{-k}}$</span> with <span>$m\in\mathbb{Z},e\in\mathbb{N}$</span>. We will denote the set of dyadic reals as <span>$\mathbb{D}$</span>.</p><p>These can be built in the libary using <a href="../api/#DedekindCutArithmetic.DyadicReal"><code>DyadicReal</code></a></p><p>Dyadic reals are closed under addition, subtraction and multiplication.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; d1 = DyadicReal(1, 2) # represents 1 ⋅ 2⁻²</code><code class="nohighlight hljs ansi" style="display:block;">0.25</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d2 = DyadicReal(2)</code><code class="nohighlight hljs ansi" style="display:block;">2.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d1 + d2</code><code class="nohighlight hljs ansi" style="display:block;">2.25</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d1 - d2</code><code class="nohighlight hljs ansi" style="display:block;">-1.75</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d1 * d2</code><code class="nohighlight hljs ansi" style="display:block;">0.5</code></pre><div class="admonition is-warning" id="Warning-d2aa1c4a6e11b9c8"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-d2aa1c4a6e11b9c8" title="Permalink"></a></header><div class="admonition-body"><p>Division is currently not supported</p></div></div><h2 id="Dyadic-interval"><a class="docs-heading-anchor" href="#Dyadic-interval">Dyadic interval</a><a id="Dyadic-interval-1"></a><a class="docs-heading-anchor-permalink" href="#Dyadic-interval" title="Permalink"></a></h2><p>There is plenty of real numbers which are not dyadic, for example <span>$0.1, \sqrt{2},\pi$</span> and so on so forth. What we will want to do, we will want a <a href="../api/#DedekindCutArithmetic.DyadicInterval"><code>DyadicInterval</code></a> <span>$[a, b]$</span> with <span>$a,b$</span> dyadic reals, which bounds the value we want to approximate. These intervals can be manipulated using interval arithmetic.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; i1 = DyadicInterval(1, 2)</code><code class="nohighlight hljs ansi" style="display:block;">[1.0, 2.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; i2 = DyadicInterval(DyadicReal(1, 1), DyadicReal(1, 2))</code><code class="nohighlight hljs ansi" style="display:block;">[0.5, 0.25]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; i1 + i2</code><code class="nohighlight hljs ansi" style="display:block;">[1.5, 2.25]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; i1 - i2</code><code class="nohighlight hljs ansi" style="display:block;">[0.75, 1.5]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; i1 * i2</code><code class="nohighlight hljs ansi" style="display:block;">[0.5, 0.5]</code></pre><p>An important thing to notice is that our library relies on <em>Kaucher interval arithmetic</em>, which allows generalized intervals <span>$[a, b]$</span> with <span>$a &gt; b$</span>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; i = DyadicInterval(3, 1)</code><code class="nohighlight hljs ansi" style="display:block;">[3.0, 1.0]</code></pre><div class="admonition is-warning" id="Warning-d2aa1c4a6e11b9c8"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-d2aa1c4a6e11b9c8" title="Permalink"></a></header><div class="admonition-body"><p>Division is currently not supported</p></div></div><h2 id="Defining-cuts"><a class="docs-heading-anchor" href="#Defining-cuts">Defining cuts</a><a id="Defining-cuts-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-cuts" title="Permalink"></a></h2><p>We finally get to the main data structure of the library: <a href="../api/#DedekindCutArithmetic.DedekindCut"><code>DedekindCut</code></a>. The intuitive idea of a dedekind cut to define a real number <span>$x$</span> is the following</p><ol><li>Find a set <span>$L\subset \mathbb{D}$</span> so that each element in <span>$L$</span> is strictly smaller than <span>$x$</span></li><li>Find a set <span>$U \subset \mathbb{D}$</span> so that each element in <span>$U$</span> is strictly bigger than <span>$x$</span>.</li><li>To get better and better approximations of <span>$x$</span>, keep increasing the upper bound of <span>$L$</span> and decreasing the lower bound of <span>$U$</span>, this will give a dyadic interval that shrinks around <span>$x$</span>.</li></ol><h3 id="Baby-example"><a class="docs-heading-anchor" href="#Baby-example">Baby example</a><a id="Baby-example-1"></a><a class="docs-heading-anchor-permalink" href="#Baby-example" title="Permalink"></a></h3><p>Let us first see a very trivial example, to get a taste of how to build dedekind cuts in practice in the library. Suppose we want to define the number <span>$2$</span> as a Dedekind cut. This is of course dummy, since that is a dyadic number and we could simply do <code>DyadicReal(2)</code> to get the exact value.</p><p>To define a cut, we need to find an expression for the lower set and upper set. In this case, we simply have</p><ul><li><strong>Lower set</strong>: <span>$\{x \in \mathbb{D}: x &lt; 2\}$</span></li><li><strong>Upper set</strong>: <span>$\{x \in \mathbb{D}: x &gt; 2\}$</span></li></ul><p>Dedekind cuts can be built with the <a href="../api/#DedekindCutArithmetic.@cut-Tuple{Any}"><code>@cut</code></a> macro and the syntax is the</p><pre><code class="language-julia hljs">@cut var_name ∈ domain, lower_set_expression, upper_set_expression</code></pre><p>If we have no idea where the the number we are defining lies on the real line, we can use <span>$\mathbb{R}$</span> for the domain. Alternatively, if we know that it lies in an interval <span>$[a, b]$</span>, we can restrict the domain to that interval. This will often lead to faster approximations. Let&#39;s see this in practice</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; my2 = @cut x ∈ ℝ, x &lt; 2, x &gt; 2;</code></pre><p>By default, this performs a <em>lazy</em> computation, that is, nothing has actually been computed so far. We can now get an arbitrary good approximation of <span>$\sqrt{2}$</span> using <a href="../api/#DedekindCutArithmetic.refine!-Tuple{DedekindCutArithmetic.AbstractDedekindReal}"><code>refine!</code></a> function.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; refine!(my2) # uses 53 bits of precision by default</code><code class="nohighlight hljs ansi" style="display:block;">[1.9999999999999998, 2.0000000000000004]</code></pre><p>The number can be queried at different precisions using the <code>precision</code> keyword. Refining to a precision <code>k</code> will produce a dyadic interval with width smaller than <span>$2^{-k}$</span>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; refine!(my2; precision=80)</code><code class="nohighlight hljs ansi" style="display:block;">[1.9999999999999998, 2.0000000000000004]</code></pre><p>It is worth mentioning that for printing, the expression is evaluated to 53 bits of precision (that is, same of a 64-bits float), hence the following in the REPL is not entirely lazy. To have a lazy computation in the REPL, suppress the output with <code>;</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @cut x ∈ [0, 3], x &lt; 2, x &gt; 2</code><code class="nohighlight hljs ansi" style="display:block;">[1.9999999999999998, 2.0000000000000004]</code></pre><div class="admonition is-warning" id="Warning-2c771e670e822fc9"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-2c771e670e822fc9" title="Permalink"></a></header><div class="admonition-body"><p>Unbounded intervals are not really supported, infinity is replaced by <code>big(typemax(Int))</code> during macro expansion.</p></div></div><h3 id="Square-root-as-Dedekind-cut"><a class="docs-heading-anchor" href="#Square-root-as-Dedekind-cut">Square root as Dedekind cut</a><a id="Square-root-as-Dedekind-cut-1"></a><a class="docs-heading-anchor-permalink" href="#Square-root-as-Dedekind-cut" title="Permalink"></a></h3><p>Let&#39;s see an example, suppose we want to define <span>$\sqrt{a}$</span> for arbitrary dyadic <span>$a$</span>. We need to find a suitable expression for <span>$L$</span> and <span>$U$</span>.</p><ul><li><strong>Lower set</strong>: Since <span>$\sqrt{a}$</span> is positive, then all negative <span>$x$</span> will be smaller than <span>$\sqrt{a}$</span> and hence belong to <span>$L$</span>. For positive <span>$x$</span>, we have <span>$x &lt; \sqrt{a} \leftrightarrow x \cdot x &lt; a$</span>. This gives an expression for the lower set</li></ul><p class="math-container">\[L = \{x \in \mathbb{D} : x &lt; 0 \lor x \cdot x &lt; 0\}\]</p><ul><li><strong>Upper set</strong>: Similarly, for a number to possibly be greater than <span>$sqrt{a}$</span>, it will need to be positive. Furthermore for positive <span>$x$</span> we have <span>$x &gt; \sqrt{a} \leftrightarrow x \cdot x &gt; a$</span>, giving the expression</li></ul><p class="math-container">\[L = \{x \in \mathbb{D} : x &gt; 0 \land x \cdot x &gt; 0\}\]</p><p>In the library, this can be implemented using the <a href="../api/#DedekindCutArithmetic.@cut-Tuple{Any}"><code>@cut</code></a> macro. We can now define a function that computes the square root of a number using dedekind cuts.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; my_sqrt(a) = @cut x ∈ ℝ, (x &lt; 0) ∨ (x * x &lt; a), (x &gt; 0) ∧ (x * x &gt; a)</code><code class="nohighlight hljs ansi" style="display:block;">my_sqrt (generic function with 1 method)</code></pre><p>We can now use it to compute the <span>$\sqrt{2}$</span> to an arbitrary precision</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sqrt2 = my_sqrt(2);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isqrt2 = refine!(sqrt2; precision=80)</code><code class="nohighlight hljs ansi" style="display:block;">[1.4142135623730949, 1.4142135623730951]</code></pre><p>and verify that the desired accuracy is achieved</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; width(isqrt2)</code><code class="nohighlight hljs ansi" style="display:block;">7.689834095926042415483712647531297110852174058634382820122936433699796202529843e-25</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; width(isqrt2) &lt; DyadicReal(1, 80)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="Cuts-with-quantifiers"><a class="docs-heading-anchor" href="#Cuts-with-quantifiers">Cuts with quantifiers</a><a id="Cuts-with-quantifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Cuts-with-quantifiers" title="Permalink"></a></h2><p>So far we have seen how to define numbers whose cuts can be expressed using propositional logic. We can however do better. Namely, we can use first-order logic, i.e. quantifiers like <span>$\forall$</span> and <span>$\exists$</span> to define more elaborated cuts.</p><p>Let us now see how to define the maximum of a function with domain <span>$[0, 1]$</span>. Again, we need to define the lower and upper set.</p><p><strong>Lower set</strong>: if <span>$a \in L$</span>, it is smaller than the maximum, i.e. there will be an element in the domain of the function for which <span>$f(x) &gt; a$</span>, this gives us the expression</p><p class="math-container">\[L = \{a \in \mathbb{D} : \exists x \in [0, 1] : f(x) &gt; a\}\]</p><p><strong>Upper set</strong>: if <span>$a \in U$</span>, it is greater than the maximum, which means it is also greater than <span>$f(x)$</span> for every <span>$x$</span> in the domain, this gives us</p><p class="math-container">\[U = \{a \in \mathbb{D} : \forall x \in [0, 1] : f(x) &lt; a\}\]</p><p>The <code>@cut</code> macro supports parsing quantifiers with a very similar syntax</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; my_max(f::Function) = @cut a ∈ ℝ, ∃(x ∈ [0, 1] : f(x) &gt; a), ∀(x ∈ [0, 1] : f(x) &lt; a)</code><code class="nohighlight hljs ansi" style="display:block;">my_max (generic function with 1 method)</code></pre><p>we can now use that to compute the maximum of <span>$f(x) = x(1 - x)$</span>, which should be <span>$\frac{1}{4}$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; my_max(x -&gt; x * (1 - x))</code><code class="nohighlight hljs ansi" style="display:block;">[0.24999999999999992, 0.25000000000000006]</code></pre><h2 id="Working-with-float-literals"><a class="docs-heading-anchor" href="#Working-with-float-literals">Working with float literals</a><a id="Working-with-float-literals-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-float-literals" title="Permalink"></a></h2><p>By default, real numbers on compuers are approximately represented via floating point numbers. Floats cannot represent all reals exactly and when typing decimals, e.g. <code>0.1</code> one does not get the exact value, but an approximation</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 0.1</code><code class="nohighlight hljs ansi" style="display:block;">0.1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a == 1//10</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; big(a)</code><code class="nohighlight hljs ansi" style="display:block;">0.1000000000000000055511151231257827021181583404541015625</code></pre><p>Unfortunately, the parsing of literals in Julia happens already before building the abstract syntax tree, hence when processing expressions with macros, the rounding sin has already happened.</p><p>For example, the following would fail to terminate</p><pre><code class="language-julia hljs">@∀ x ∈ ℝ: 0.1000000000000000000001 &gt; 0.1</code></pre><p>because when parsing the literals both produce the same floating point number.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 0.1000000000000000000001 == 0.1</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>When working with rational numbers in decimal form, use the <a href="../api/#DedekindCutArithmetic.@exact_str-Tuple{AbstractString}"><code>@exact_str</code></a> string macro, which ensures the literal is parsed to the correct rational number.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; exact&quot;0.1&quot;</code><code class="nohighlight hljs ansi" style="display:block;">[0.099999999999999867, 0.10000000000000009]</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @∀ x ∈ ℝ: exact&quot;0.1000000000000000000001&quot; &gt; exact&quot;0.1&quot;</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.2 on <span class="colophon-date" title="Wednesday 14 May 2025 07:32">Wednesday 14 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
